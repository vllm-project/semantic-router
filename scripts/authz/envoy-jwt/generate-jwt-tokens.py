#!/usr/bin/env python3
"""Mint signed JWTs for each test user in the EG RBAC integration test.

Reads the RSA private key generated by generate-jwt-keys.py and creates
one JWT per test user, writing them to a shell-sourceable file.

Outputs (in --output-dir):
  - tokens.env : shell-sourceable file exporting JWT_<USER>=<token>

Test users and their claims (matching the router's role_bindings):
  alice   → sub=alice,   groups=[platform-admins]
  bob     → sub=bob,     groups=[premium-tier]
  carol   → sub=carol,   groups=[free-tier]
  dave    → sub=dave,    groups=[premium-tier, platform-admins]
  unknown → sub=unknown, groups=[]
  expired → sub=expired, groups=[premium-tier]          (exp in past)
"""

import argparse
import datetime
import json
import os
import sys

import jwt  # PyJWT


# Test user definitions: (env_var_suffix, sub, groups_csv, expired?)
# groups is a comma-separated string (NOT an array) because EG's claimToHeaders
# does not support array-type JWT claims. The router's ParseUserGroups splits on
# commas, so "premium-tier,platform-admins" → ["premium-tier", "platform-admins"].
TEST_USERS = [
    ("ALICE",   "alice",   "platform-admins",                  False),
    ("BOB",     "bob",     "premium-tier",                     False),
    ("CAROL",   "carol",   "free-tier",                        False),
    ("DAVE",    "dave",    "premium-tier,platform-admins",     False),
    ("UNKNOWN", "unknown", "",                                 False),
    ("EXPIRED", "expired", "premium-tier",                     True),
]


def load_private_key(path: str) -> str:
    with open(path, "r") as f:
        return f.read()


def load_kid(jwks_path: str) -> str:
    with open(jwks_path, "r") as f:
        jwks = json.load(f)
    return jwks["keys"][0]["kid"]


def mint_jwt(
    private_key_pem: str,
    kid: str,
    sub: str,
    groups_csv: str,
    issuer: str,
    audience: str,
    expired: bool = False,
) -> str:
    now = datetime.datetime.now(datetime.timezone.utc)
    if expired:
        exp = now - datetime.timedelta(hours=1)
    else:
        exp = now + datetime.timedelta(hours=24)

    payload = {
        "iss": issuer,
        "aud": audience,
        "sub": sub,
        "iat": now,
        "exp": exp,
    }
    # Store groups as a comma-separated string (not array) so EG's
    # claimToHeaders can extract it directly into x-jwt-groups header.
    if groups_csv:
        payload["groups"] = groups_csv

    headers = {"kid": kid}
    return jwt.encode(payload, private_key_pem, algorithm="RS256", headers=headers)


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--private-key",
        default=None,
        help="Path to RSA private key PEM (default: jwt-artifacts/private-key.pem)",
    )
    parser.add_argument(
        "--jwks",
        default=None,
        help="Path to jwks.json to read kid (default: jwt-artifacts/jwks.json)",
    )
    parser.add_argument(
        "--output-dir",
        default=None,
        help="Directory to write tokens.env (default: jwt-artifacts/)",
    )
    parser.add_argument(
        "--issuer",
        default="https://eg-jwt-issuer.example.com",
        help="JWT issuer (iss) claim",
    )
    parser.add_argument(
        "--audience",
        default="semantic-router",
        help="JWT audience (aud) claim",
    )
    args = parser.parse_args()

    script_dir = os.path.dirname(os.path.abspath(__file__))
    artifacts_dir = os.path.join(script_dir, "jwt-artifacts")

    private_key_path = args.private_key or os.path.join(artifacts_dir, "private-key.pem")
    jwks_path = args.jwks or os.path.join(artifacts_dir, "jwks.json")
    output_dir = args.output_dir or artifacts_dir

    if not os.path.exists(private_key_path):
        print(f"ERROR: Private key not found: {private_key_path}", file=sys.stderr)
        print("Run generate-jwt-keys.py first.", file=sys.stderr)
        return 1

    private_key_pem = load_private_key(private_key_path)
    kid = load_kid(jwks_path)
    os.makedirs(output_dir, exist_ok=True)

    print(f"Minting JWTs (kid={kid}, iss={args.issuer}, aud={args.audience})...")

    lines = [
        "# Auto-generated JWT tokens for EG RBAC integration test",
        f"# kid={kid}  iss={args.issuer}  aud={args.audience}",
        f"# Generated: {datetime.datetime.now(datetime.timezone.utc).isoformat()}",
        "",
    ]

    for var_suffix, sub, groups_csv, expired in TEST_USERS:
        token = mint_jwt(
            private_key_pem, kid, sub, groups_csv, args.issuer, args.audience, expired
        )
        env_var = f"JWT_{var_suffix}"
        lines.append(f'export {env_var}="{token}"')
        label = f"{sub} (groups={groups_csv!r})"
        if expired:
            label += " [EXPIRED]"
        print(f"  {env_var}: {label}")

    tokens_path = os.path.join(output_dir, "tokens.env")
    with open(tokens_path, "w") as f:
        f.write("\n".join(lines) + "\n")
    print(f"\nTokens written to: {tokens_path}")
    print("Source with: source tokens.env")
    return 0


if __name__ == "__main__":
    sys.exit(main())
