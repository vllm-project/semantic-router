name: Kubernetes Integration Test

# This workflow tests the CORE semantic-router Kubernetes deployment.
#
# Test Scope:
#   ‚úÖ Core deployment (namespace, pvc, deployment, service, configmap)
#   ‚úÖ Manifest validation (kubeconform)
#   ‚úÖ Service connectivity (gRPC, metrics, API ports)
#   ‚úÖ API functionality testing (14 comprehensive tests)
#   ‚úÖ Security scanning (Trivy, Checkov)
#   ‚úÖ Basic syntax validation for observability and ai-gateway configs
#   ‚úÖ kind cluster integration with CI-optimized configuration
#   ‚úÖ Error handling and edge case testing
#   ‚úÖ Performance testing with concurrent requests
#
# Out of Scope (planned for follow-up PRs):
#   üîÑ Observability stack deployment (Prometheus + Grafana)
#   üîÑ AI Gateway end-to-end testing (Envoy Gateway + InferencePool)
#
# CI Optimizations:
#   - Uses CI-specific kind configuration (single node, reduced resources)
#   - Generates kind-config.yaml dynamically (no models mount needed)
#   - Optimized for GitHub Actions runner constraints

on:
  pull_request:
    paths:
      - "deploy/kubernetes/**"
      - ".github/workflows/k8s-integration-test.yml"
      - "Dockerfile.extproc"
      - "tools/kind/**"
  workflow_dispatch: # Allow manual triggering
  schedule:
    # Run nightly at 3:00 AM UTC
    - cron: "0 3 * * *"

env:
  KIND_VERSION: v0.20.0
  KUBECTL_VERSION: v1.28.0
  KUSTOMIZE_VERSION: v5.2.1

jobs:
  validate-manifests:
    name: Validate Kubernetes Manifests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Kustomize
        uses: imranismail/setup-kustomize@v2
        with:
          kustomize-version: ${{ env.KUSTOMIZE_VERSION }}

      - name: Validate Kustomize build
        run: |
          echo "Building kustomization..."
          kustomize build deploy/kubernetes > /tmp/k8s-manifests.yaml
          echo "Kustomize build successful!"
          echo "Generated manifests:"
          cat /tmp/k8s-manifests.yaml

      - name: Setup kubeconform
        run: |
          wget https://github.com/yannh/kubeconform/releases/latest/download/kubeconform-linux-amd64.tar.gz
          tar xf kubeconform-linux-amd64.tar.gz
          sudo mv kubeconform /usr/local/bin/
          kubeconform -v

      - name: Validate manifests with kubeconform
        run: |
          echo "Validating Kubernetes manifests..."
          kustomize build deploy/kubernetes | \
            kubeconform -strict -summary \
              -kubernetes-version 1.28.0 \
              -schema-location default \
              -schema-location 'https://raw.githubusercontent.com/datreeio/CRDs-catalog/main/{{.Group}}/{{.ResourceKind}}_{{.ResourceAPIVersion}}.json' \
              -skip CustomResourceDefinition \
              -ignore-missing-schemas

      - name: Upload validated manifests
        uses: actions/upload-artifact@v4
        with:
          name: k8s-manifests
          path: /tmp/k8s-manifests.yaml
          retention-days: 5

  kind-integration-test:
    name: kind Cluster Integration Test
    runs-on: ubuntu-latest
    needs: validate-manifests
    timeout-minutes: 45 # Increased to account for model downloads

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Free up disk space before build
        run: |
          echo "=== Initial disk usage ==="
          df -h
          echo ""
          echo "=== Cleaning up system ==="
          # Remove unnecessary packages and caches
          sudo apt-get clean
          sudo apt-get autoremove -y
          sudo rm -rf /var/lib/apt/lists/*
          sudo rm -rf /tmp/*
          sudo rm -rf /var/tmp/*

          # Clean Docker system
          docker system prune -af --volumes

          # Remove large unnecessary files/directories
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL

          echo ""
          echo "=== Disk usage after cleanup ==="
          df -h

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate kind configuration for CI
        run: |
          echo "Creating CI-optimized kind configuration..."
          # Create a simplified kind config for CI that doesn't require models mount
          cat > tools/kind/kind-config.yaml << 'EOF'
          # kind cluster configuration for CI testing
          kind: Cluster
          apiVersion: kind.x-k8s.io/v1alpha4
          name: semantic-router-cluster
          nodes:
            - role: control-plane
              # Optimized for CI environment with limited resources
              extraPortMappings:
                - containerPort: 30080
                  hostPort: 30080
                  protocol: TCP
              kubeadmConfigPatches:
                - |
                  kind: InitConfiguration
                  nodeRegistration:
                    kubeletExtraArgs:
                      # Reduced resource limits for CI
                      system-reserved: memory=512Mi,cpu=250m
                      kube-reserved: memory=512Mi,cpu=250m
                      eviction-hard: memory.available<512Mi,nodefs.available<10%
                - |
                  kind: ClusterConfiguration
                  apiServer:
                    extraArgs:
                      max-requests-inflight: "200"
                      max-mutating-requests-inflight: "100"
                  etcd:
                    local:
                      extraArgs:
                        quota-backend-bytes: "4294967296" # 4GB (reduced from 8GB)
          EOF
          echo "Generated CI-optimized kind-config.yaml:"
          cat tools/kind/kind-config.yaml

      - name: Create kind cluster
        uses: helm/kind-action@v1.8.0
        with:
          version: ${{ env.KIND_VERSION }}
          config: tools/kind/kind-config.yaml
          cluster_name: semantic-router-cluster
          wait: 120s

      - name: Build semantic-router image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.extproc
          tags: ghcr.io/vllm-project/semantic-router/extproc:test
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Load image into kind cluster
        run: |
          echo "Loading image into kind cluster..."
          kind load docker-image ghcr.io/vllm-project/semantic-router/extproc:test --name semantic-router-cluster
          echo "Image loaded successfully!"

      - name: Clean up after image build
        run: |
          echo "=== Cleaning up Docker build artifacts ==="
          # Remove build cache and unused images
          docker builder prune -af
          docker image prune -af

          # Keep only the images we need
          docker images

          echo ""
          echo "=== Disk usage after build cleanup ==="
          df -h

      - name: Verify cluster
        run: |
          echo "=== Verifying kind cluster ==="
          kubectl cluster-info
          kubectl get nodes -o wide
          kubectl version

          # Verify cluster is ready
          kubectl wait --for=condition=Ready nodes --all --timeout=120s

          # Check available resources
          echo "=== Node resources ==="
          kubectl describe nodes

      - name: Setup Kustomize
        uses: imranismail/setup-kustomize@v2
        with:
          kustomize-version: ${{ env.KUSTOMIZE_VERSION }}

      - name: Create CI test overlay
        run: |
          # Create a simple test overlay directory
          mkdir -p deploy/kubernetes/ci-test
          cd deploy/kubernetes/ci-test

          # Create a simple kustomization that patches the base for CI
          cat > kustomization.yaml << EOF
          apiVersion: kustomize.config.k8s.io/v1beta1
          kind: Kustomization

          resources:
          - ../

          # Use the test image
          images:
          - name: ghcr.io/vllm-project/semantic-router/extproc
            newTag: test

          # Patch for CI - reduce resources and set imagePullPolicy
          patches:
          - patch: |-
              - op: replace
                path: /spec/template/spec/containers/0/resources/requests/memory
                value: "1Gi"
              - op: replace
                path: /spec/template/spec/containers/0/resources/requests/cpu
                value: "500m"
              - op: replace
                path: /spec/template/spec/containers/0/resources/limits/memory
                value: "2Gi"
              - op: replace
                path: /spec/template/spec/containers/0/resources/limits/cpu
                value: "1"
              - op: add
                path: /spec/template/spec/containers/0/imagePullPolicy
                value: "IfNotPresent"
            target:
              kind: Deployment
              name: semantic-router
          EOF

          echo "=== Generated CI test kustomization ==="
          cat kustomization.yaml

      - name: Pre-flight check for Hugging Face connectivity
        run: |
          echo "Testing Hugging Face Hub connectivity..."
          curl -I https://huggingface.co || {
            echo "‚ö†Ô∏è  Warning: Cannot reach huggingface.co"
          }

          # Test one of the model repos
          curl -I https://huggingface.co/LLM-Semantic-Router/category_classifier_modernbert-base_model || {
            echo "‚ö†Ô∏è  Warning: Cannot reach model repository"
          }

          echo "‚úì Connectivity check completed"

      - name: Final disk cleanup before deployment
        run: |
          echo "=== Final cleanup before deployment ==="
          # Clean up any remaining build artifacts
          docker system prune -f

          # Clear system caches
          sudo sync
          echo 3 | sudo tee /proc/sys/vm/drop_caches > /dev/null || true

          echo "=== Final disk usage ==="
          df -h

          echo "=== Available memory ==="
          free -h

      - name: Deploy to kind cluster
        run: |
          echo "Deploying semantic-router to kind cluster..."
          kustomize build deploy/kubernetes/ci-test | kubectl apply -f -

          echo "Waiting for namespace to be active..."
          kubectl wait --for=jsonpath='{.status.phase}'=Active namespace/vllm-semantic-router-system --timeout=60s

          echo "Deployment initiated. Checking resources..."
          kubectl get all -n vllm-semantic-router-system

      - name: Wait for deployment readiness
        run: |
          echo "Waiting for deployment to be ready..."

          # Wait for PVC to be bound
          echo "Waiting for PVC to be bound..."
          kubectl wait --for=jsonpath='{.status.phase}'=Bound pvc/semantic-router-models -n vllm-semantic-router-system --timeout=120s || {
            echo "PVC binding timeout. Checking PVC status..."
            kubectl describe pvc -n vllm-semantic-router-system
            exit 1
          }

          # Wait for pods to be created
          echo "Waiting for pods to be created..."
          timeout 120 bash -c 'until kubectl get pods -n vllm-semantic-router-system | grep -q semantic-router; do echo "Waiting for pod creation..."; sleep 5; done'

          # Show pod status
          kubectl get pods -n vllm-semantic-router-system

          # Wait for init container to complete (model download)
          echo "Waiting for init container to complete (downloading models)..."
          kubectl wait --for=condition=Initialized pods -l app=semantic-router -n vllm-semantic-router-system --timeout=600s || {
            echo "‚ùå Init container did not complete in time. Showing logs..."
            kubectl logs -n vllm-semantic-router-system -l app=semantic-router -c model-downloader --tail=200 || true
            kubectl describe pods -n vllm-semantic-router-system -l app=semantic-router
            exit 1
          }

          # Wait for main container to be ready
          echo "Waiting for main container to be ready..."
          kubectl wait --for=condition=Ready pods -l app=semantic-router -n vllm-semantic-router-system --timeout=300s || {
            echo "‚ùå Pod did not become ready in time. Showing status and logs..."
            kubectl describe pods -n vllm-semantic-router-system -l app=semantic-router
            kubectl logs -n vllm-semantic-router-system -l app=semantic-router --tail=200 || true
            exit 1
          }

          echo "‚úÖ Deployment is ready!"

      - name: Verify deployment
        run: |
          echo "=== Verifying Deployment ==="

          # Check deployment status
          kubectl get deployment -n vllm-semantic-router-system semantic-router -o wide

          # Check pod status
          kubectl get pods -n vllm-semantic-router-system -o wide

          # Check services
          kubectl get svc -n vllm-semantic-router-system

          # Check configmaps
          kubectl get configmap -n vllm-semantic-router-system

          # Verify pod is running
          POD_STATUS=$(kubectl get pods -n vllm-semantic-router-system -l app=semantic-router -o jsonpath='{.items[0].status.phase}')
          if [ "$POD_STATUS" != "Running" ]; then
            echo "Error: Pod is not running. Status: $POD_STATUS"
            kubectl describe pods -n vllm-semantic-router-system -l app=semantic-router
            exit 1
          fi

          echo "‚úì Pod is running"

          # Verify all containers are ready
          READY_CONTAINERS=$(kubectl get pods -n vllm-semantic-router-system -l app=semantic-router -o jsonpath='{.items[0].status.containerStatuses[0].ready}')
          if [ "$READY_CONTAINERS" != "true" ]; then
            echo "Error: Container is not ready"
            kubectl describe pods -n vllm-semantic-router-system -l app=semantic-router
            exit 1
          fi

          echo "‚úì All containers are ready"

      - name: Test service connectivity
        run: |
          echo "=== Testing Service Connectivity ==="

          # Get pod name
          POD_NAME=$(kubectl get pods -n vllm-semantic-router-system -l app=semantic-router -o jsonpath='{.items[0].metadata.name}')
          echo "Pod name: $POD_NAME"

          # Test basic port connectivity
          echo "Testing ports..."
          kubectl exec -n vllm-semantic-router-system $POD_NAME -- timeout 5 nc -zv localhost 50051 || echo "gRPC port test failed"
          kubectl exec -n vllm-semantic-router-system $POD_NAME -- timeout 5 nc -zv localhost 9190 || echo "Metrics port test failed"
          kubectl exec -n vllm-semantic-router-system $POD_NAME -- timeout 5 nc -zv localhost 8080 || echo "API port test failed"

          echo "‚úì Service connectivity tests completed"

      - name: Test API functionality
        run: |
          echo "=== Testing API Functionality ==="

          # Get pod name
          POD_NAME=$(kubectl get pods -n vllm-semantic-router-system -l app=semantic-router -o jsonpath='{.items[0].metadata.name}')
          echo "Pod name: $POD_NAME"

          # Wait for API to be ready
          echo "Waiting for API to be ready..."
          timeout 60 bash -c 'until kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s http://localhost:8080/health > /dev/null; do echo "Waiting for API..."; sleep 5; done'

          # Test 1: Health check endpoint
          echo "Testing health check endpoint..."
          HEALTH_RESPONSE=$(kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s http://localhost:8080/health)
          echo "Health response: $HEALTH_RESPONSE"
          if echo "$HEALTH_RESPONSE" | grep -q "ok\|healthy\|status"; then
            echo "‚úì Health check passed"
          else
            echo "‚ùå Health check failed"
            exit 1
          fi

          # Test 2: Models endpoint
          echo "Testing models endpoint..."
          MODELS_RESPONSE=$(kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s http://localhost:8080/v1/models)
          echo "Models response: $MODELS_RESPONSE"
          if echo "$MODELS_RESPONSE" | grep -q "MoM\|object.*list"; then
            echo "‚úì Models endpoint passed"
          else
            echo "‚ùå Models endpoint failed"
            exit 1
          fi

          # Test 3: Intent classification
          echo "Testing intent classification..."
          INTENT_RESPONSE=$(kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s -X POST http://localhost:8080/api/v1/classify/intent \
            -H "Content-Type: application/json" \
            -d '{"text": "What is machine learning?"}')
          echo "Intent response: $INTENT_RESPONSE"
          if echo "$INTENT_RESPONSE" | grep -q "category\|confidence\|score"; then
            echo "‚úì Intent classification passed"
          else
            echo "‚ùå Intent classification failed"
            exit 1
          fi

          # Test 4: PII detection
          echo "Testing PII detection..."
          PII_RESPONSE=$(kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s -X POST http://localhost:8080/api/v1/classify/pii \
            -H "Content-Type: application/json" \
            -d '{"text": "My email is john.doe@example.com"}')
          echo "PII response: $PII_RESPONSE"
          if echo "$PII_RESPONSE" | grep -q "pii\|detected\|confidence"; then
            echo "‚úì PII detection passed"
          else
            echo "‚ùå PII detection failed"
            exit 1
          fi

          # Test 5: Security detection
          echo "Testing security detection..."
          SECURITY_RESPONSE=$(kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s -X POST http://localhost:8080/api/v1/classify/security \
            -H "Content-Type: application/json" \
            -d '{"text": "This is a normal question about programming"}')
          echo "Security response: $SECURITY_RESPONSE"
          if echo "$SECURITY_RESPONSE" | grep -q "jailbreak\|security\|confidence"; then
            echo "‚úì Security detection passed"
          else
            echo "‚ùå Security detection failed"
            exit 1
          fi

          # Test 6: Batch classification
          echo "Testing batch classification..."
          BATCH_RESPONSE=$(kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s -X POST http://localhost:8080/api/v1/classify/batch \
            -H "Content-Type: application/json" \
            -d '{"texts": ["What is AI?", "My phone is 123-456-7890"], "task_type": "intent"}')
          echo "Batch response: $BATCH_RESPONSE"
          if echo "$BATCH_RESPONSE" | grep -q "results\|classifications"; then
            echo "‚úì Batch classification passed"
          else
            echo "‚ùå Batch classification failed"
            exit 1
          fi

          # Test 7: Models info endpoint
          echo "Testing models info endpoint..."
          MODELS_INFO_RESPONSE=$(kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s http://localhost:8080/info/models)
          echo "Models info response: $MODELS_INFO_RESPONSE"
          if echo "$MODELS_INFO_RESPONSE" | grep -q "models\|loaded\|status"; then
            echo "‚úì Models info endpoint passed"
          else
            echo "‚ùå Models info endpoint failed"
            exit 1
          fi

          # Test 8: Classifier info endpoint
          echo "Testing classifier info endpoint..."
          CLASSIFIER_INFO_RESPONSE=$(kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s http://localhost:8080/info/classifier)
          echo "Classifier info response: $CLASSIFIER_INFO_RESPONSE"
          if echo "$CLASSIFIER_INFO_RESPONSE" | grep -q "classifier\|config\|status"; then
            echo "‚úì Classifier info endpoint passed"
          else
            echo "‚ùå Classifier info endpoint failed"
            exit 1
          fi

          # Test 9: API overview endpoint
          echo "Testing API overview endpoint..."
          API_OVERVIEW_RESPONSE=$(kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s http://localhost:8080/api/v1)
          echo "API overview response: $API_OVERVIEW_RESPONSE"
          if echo "$API_OVERVIEW_RESPONSE" | grep -q "endpoints\|api\|version"; then
            echo "‚úì API overview endpoint passed"
          else
            echo "‚ùå API overview endpoint failed"
            exit 1
          fi

          # Test 10: Metrics endpoint
          echo "Testing metrics endpoint..."
          METRICS_RESPONSE=$(kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s http://localhost:8080/metrics/classification)
          echo "Metrics response: $METRICS_RESPONSE"
          if echo "$METRICS_RESPONSE" | grep -q "metrics\|classification\|prometheus"; then
            echo "‚úì Metrics endpoint passed"
          else
            echo "‚ùå Metrics endpoint failed"
            exit 1
          fi

          echo "‚úÖ All API functionality tests passed!"

      - name: Check logs
        if: always()
        run: |
          echo "=== Deployment Logs ==="
          kubectl logs -n vllm-semantic-router-system -l app=semantic-router --tail=200 --all-containers=true || true

          echo "=== Events ==="
          kubectl get events -n vllm-semantic-router-system --sort-by='.lastTimestamp' || true

      - name: Export cluster logs on failure
        if: failure()
        run: |
          echo "=== Exporting cluster information for debugging ==="
          mkdir -p /tmp/k8s-logs

          # Export kind cluster logs
          echo "=== Kind cluster logs ==="
          docker logs semantic-router-cluster-control-plane > /tmp/k8s-logs/kind-control-plane.log || true

          # Export pod descriptions
          kubectl describe pods -n vllm-semantic-router-system > /tmp/k8s-logs/pod-descriptions.txt || true

          # Export deployment description
          kubectl describe deployment -n vllm-semantic-router-system > /tmp/k8s-logs/deployment-description.txt || true

          # Export all logs
          kubectl logs -n vllm-semantic-router-system -l app=semantic-router --all-containers=true --previous > /tmp/k8s-logs/previous-logs.txt || true
          kubectl logs -n vllm-semantic-router-system -l app=semantic-router --all-containers=true > /tmp/k8s-logs/current-logs.txt || true

          # Export events
          kubectl get events -n vllm-semantic-router-system --sort-by='.lastTimestamp' > /tmp/k8s-logs/events.txt || true

          # Export resource status
          kubectl get all -n vllm-semantic-router-system -o yaml > /tmp/k8s-logs/all-resources.yaml || true

          # Export kind cluster info
          kind get kubeconfig --name semantic-router-cluster > /tmp/k8s-logs/kind-kubeconfig.yaml || true

      - name: Upload cluster logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: k8s-cluster-logs
          path: /tmp/k8s-logs/
          retention-days: 7

      - name: Cleanup
        if: always()
        run: |
          echo "Cleaning up resources..."
          kubectl delete namespace vllm-semantic-router-system --timeout=60s || true
          echo "Cleaning up kind cluster..."
          kind delete cluster --name semantic-router-cluster || true
          echo "Cleaning up CI test directory..."
          rm -rf deploy/kubernetes/ci-test || true

  test-api-functionality:
    name: Test API Functionality
    runs-on: ubuntu-latest
    needs: kind-integration-test
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Create kind cluster for API testing
        uses: helm/kind-action@v1.8.0
        with:
          version: ${{ env.KIND_VERSION }}
          config: |
            kind: Cluster
            apiVersion: kind.x-k8s.io/v1alpha4
            name: api-test-cluster
            nodes:
              - role: control-plane
                extraPortMappings:
                  - containerPort: 30080
                    hostPort: 30080
                    protocol: TCP
                kubeadmConfigPatches:
                  - |
                    kind: InitConfiguration
                    nodeRegistration:
                      kubeletExtraArgs:
                        system-reserved: memory=512Mi,cpu=250m
                        kube-reserved: memory=512Mi,cpu=250m
                        eviction-hard: memory.available<512Mi,nodefs.available<10%
          cluster_name: api-test-cluster
          wait: 120s

      - name: Build and load image
        run: |
          # Build image
          docker build -f ./Dockerfile.extproc -t ghcr.io/vllm-project/semantic-router/extproc:api-test .

          # Load into kind
          kind load docker-image ghcr.io/vllm-project/semantic-router/extproc:api-test --name api-test-cluster

      - name: Setup Kustomize
        uses: imranismail/setup-kustomize@v2
        with:
          kustomize-version: ${{ env.KUSTOMIZE_VERSION }}

      - name: Create API test overlay
        run: |
          mkdir -p deploy/kubernetes/api-test
          cd deploy/kubernetes/api-test

          cat > kustomization.yaml << EOF
          apiVersion: kustomize.config.k8s.io/v1beta1
          kind: Kustomization

          resources:
          - ../

          images:
          - name: ghcr.io/vllm-project/semantic-router/extproc
            newTag: api-test

          patches:
          - patch: |-
              - op: replace
                path: /spec/template/spec/containers/0/resources/requests/memory
                value: "512Mi"
              - op: replace
                path: /spec/template/spec/containers/0/resources/requests/cpu
                value: "250m"
              - op: replace
                path: /spec/template/spec/containers/0/resources/limits/memory
                value: "1Gi"
              - op: replace
                path: /spec/template/spec/containers/0/resources/limits/cpu
                value: "500m"
              - op: add
                path: /spec/template/spec/containers/0/imagePullPolicy
                value: "IfNotPresent"
            target:
              kind: Deployment
              name: semantic-router
          EOF

      - name: Deploy for API testing
        run: |
          kustomize build deploy/kubernetes/api-test | kubectl apply -f -

          # Wait for deployment
          kubectl wait --for=jsonpath='{.status.phase}'=Active namespace/vllm-semantic-router-system --timeout=60s
          kubectl wait --for=jsonpath='{.status.phase}'=Bound pvc/semantic-router-models -n vllm-semantic-router-system --timeout=120s
          kubectl wait --for=condition=Initialized pods -l app=semantic-router -n vllm-semantic-router-system --timeout=600s
          kubectl wait --for=condition=Ready pods -l app=semantic-router -n vllm-semantic-router-system --timeout=300s

      - name: Run comprehensive API tests
        run: |
          echo "=== Running Comprehensive API Tests ==="

          POD_NAME=$(kubectl get pods -n vllm-semantic-router-system -l app=semantic-router -o jsonpath='{.items[0].metadata.name}')
          echo "Pod name: $POD_NAME"

          # Wait for API to be ready
          echo "Waiting for API to be ready..."
          timeout 120 bash -c 'until kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s http://localhost:8080/health > /dev/null 2>&1; do echo "Waiting for API..."; sleep 10; done'

          # Test results tracking
          TESTS_PASSED=0
          TESTS_FAILED=0
          TOTAL_TESTS=0

          # Function to run a test
          run_test() {
            local test_name="$1"
            local test_command="$2"
            local expected_pattern="$3"
            
            echo ""
            echo "üß™ Testing: $test_name"
            echo "Command: $test_command"
            
            TOTAL_TESTS=$((TOTAL_TESTS + 1))
            
            if eval "$test_command" | grep -q "$expected_pattern"; then
              echo "‚úÖ $test_name PASSED"
              TESTS_PASSED=$((TESTS_PASSED + 1))
            else
              echo "‚ùå $test_name FAILED"
              TESTS_FAILED=$((TESTS_FAILED + 1))
              echo "Response:"
              eval "$test_command" || true
            fi
          }

          # Test 1: Health check
          run_test "Health Check" \
            "kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s http://localhost:8080/health" \
            "ok\|healthy\|status"

          # Test 2: Models endpoint
          run_test "Models Endpoint" \
            "kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s http://localhost:8080/v1/models" \
            "MoM\|object.*list"

          # Test 3: Intent classification
          run_test "Intent Classification" \
            "kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s -X POST http://localhost:8080/api/v1/classify/intent -H 'Content-Type: application/json' -d '{\"text\": \"What is machine learning?\"}'" \
            "category\|confidence\|score"

          # Test 4: PII detection
          run_test "PII Detection" \
            "kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s -X POST http://localhost:8080/api/v1/classify/pii -H 'Content-Type: application/json' -d '{\"text\": \"My email is john.doe@example.com\"}'" \
            "pii\|detected\|confidence"

          # Test 5: Security detection
          run_test "Security Detection" \
            "kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s -X POST http://localhost:8080/api/v1/classify/security -H 'Content-Type: application/json' -d '{\"text\": \"This is a normal question about programming\"}'" \
            "jailbreak\|security\|confidence"

          # Test 6: Batch classification
          run_test "Batch Classification" \
            "kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s -X POST http://localhost:8080/api/v1/classify/batch -H 'Content-Type: application/json' -d '{\"texts\": [\"What is AI?\", \"My phone is 123-456-7890\"], \"task_type\": \"intent\"}'" \
            "results\|classifications"

          # Test 7: Models info
          run_test "Models Info" \
            "kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s http://localhost:8080/info/models" \
            "models\|loaded\|status"

          # Test 8: Classifier info
          run_test "Classifier Info" \
            "kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s http://localhost:8080/info/classifier" \
            "classifier\|config\|status"

          # Test 9: API overview
          run_test "API Overview" \
            "kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s http://localhost:8080/api/v1" \
            "endpoints\|api\|version"

          # Test 10: Metrics
          run_test "Metrics Endpoint" \
            "kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s http://localhost:8080/metrics/classification" \
            "metrics\|classification\|prometheus"

          # Test 11: Error handling - invalid JSON
          run_test "Error Handling - Invalid JSON" \
            "kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s -X POST http://localhost:8080/api/v1/classify/intent -H 'Content-Type: application/json' -d 'invalid json' | grep -q 'error\|invalid\|bad'" \
            "error\|invalid\|bad"

          # Test 12: Error handling - missing required fields
          run_test "Error Handling - Missing Fields" \
            "kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s -X POST http://localhost:8080/api/v1/classify/intent -H 'Content-Type: application/json' -d '{}' | grep -q 'error\|missing\|required'" \
            "error\|missing\|required"

          # Test 13: Performance test - multiple requests
          echo ""
          echo "üöÄ Performance Test: Multiple concurrent requests"
          for i in {1..5}; do
            kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s -X POST http://localhost:8080/api/v1/classify/intent \
              -H 'Content-Type: application/json' \
              -d "{\"text\": \"Test question $i about technology\"}" > /dev/null &
          done
          wait
          echo "‚úÖ Performance test completed"

          # Test 14: Different text categories
          echo ""
          echo "üìö Testing different text categories"

          # Math question
          run_test "Math Category" \
            "kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s -X POST http://localhost:8080/api/v1/classify/intent -H 'Content-Type: application/json' -d '{\"text\": \"What is the derivative of x^2?\"}'" \
            "category\|confidence"

          # Business question  
          run_test "Business Category" \
            "kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s -X POST http://localhost:8080/api/v1/classify/intent -H 'Content-Type: application/json' -d '{\"text\": \"How can I improve my company's revenue?\"}'" \
            "category\|confidence"

          # Health question
          run_test "Health Category" \
            "kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s -X POST http://localhost:8080/api/v1/classify/intent -H 'Content-Type: application/json' -d '{\"text\": \"What are the symptoms of a cold?\"}'" \
            "category\|confidence"

          # Print test summary
          echo ""
          echo "=== API Test Summary ==="
          echo "Total Tests: $TOTAL_TESTS"
          echo "Passed: $TESTS_PASSED"
          echo "Failed: $TESTS_FAILED"
          echo "Success Rate: $(( (TESTS_PASSED * 100) / TOTAL_TESTS ))%"

          if [ $TESTS_FAILED -gt 0 ]; then
            echo ""
            echo "‚ùå Some API tests failed. Check the logs above for details."
            exit 1
          else
            echo ""
            echo "‚úÖ All API tests passed!"
          fi

      - name: Export API test logs on failure
        if: failure()
        run: |
          echo "=== Exporting API test logs for debugging ==="
          mkdir -p /tmp/api-test-logs

          POD_NAME=$(kubectl get pods -n vllm-semantic-router-system -l app=semantic-router -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "pod-not-found")

          # Export pod logs
          kubectl logs -n vllm-semantic-router-system $POD_NAME --all-containers=true > /tmp/api-test-logs/pod-logs.txt 2>/dev/null || true

          # Export pod description
          kubectl describe pods -n vllm-semantic-router-system > /tmp/api-test-logs/pod-description.txt 2>/dev/null || true

          # Export events
          kubectl get events -n vllm-semantic-router-system --sort-by='.lastTimestamp' > /tmp/api-test-logs/events.txt 2>/dev/null || true

          # Test API responses for debugging
          kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s http://localhost:8080/health > /tmp/api-test-logs/health-response.txt 2>/dev/null || true
          kubectl exec -n vllm-semantic-router-system $POD_NAME -- curl -s http://localhost:8080/v1/models > /tmp/api-test-logs/models-response.txt 2>/dev/null || true

      - name: Upload API test logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: api-test-logs
          path: /tmp/api-test-logs/
          retention-days: 7

      - name: Cleanup API test
        if: always()
        run: |
          echo "Cleaning up API test resources..."
          kubectl delete namespace vllm-semantic-router-system --timeout=60s || true
          kind delete cluster --name api-test-cluster || true
          rm -rf deploy/kubernetes/api-test || true

  test-with-custom-config:
    name: Test with Custom Configuration
    runs-on: ubuntu-latest
    needs: validate-manifests

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Kustomize
        uses: imranismail/setup-kustomize@v2
        with:
          kustomize-version: ${{ env.KUSTOMIZE_VERSION }}

      - name: Test kustomize with different overlays
        run: |
          echo "Testing base kustomization..."
          kustomize build deploy/kubernetes > /tmp/base-manifests.yaml

          echo "Validating generated resources..."

          # Check if all expected resources are present
          if ! grep -q "kind: Namespace" /tmp/base-manifests.yaml; then
            echo "Error: Namespace not found"
            exit 1
          fi

          if ! grep -q "kind: Deployment" /tmp/base-manifests.yaml; then
            echo "Error: Deployment not found"
            exit 1
          fi

          if ! grep -q "kind: Service" /tmp/base-manifests.yaml; then
            echo "Error: Service not found"
            exit 1
          fi

          if ! grep -q "kind: ConfigMap" /tmp/base-manifests.yaml; then
            echo "Error: ConfigMap not found"
            exit 1
          fi

          echo "‚úì All expected resources are present"

      - name: Verify ConfigMap generation
        run: |
          echo "Checking ConfigMap generation..."
          kustomize build deploy/kubernetes | grep -A 20 "kind: ConfigMap"

          # Verify config files are included
          if ! kustomize build deploy/kubernetes | grep -q "config.yaml"; then
            echo "Warning: config.yaml might not be properly included in ConfigMap"
          fi

          if ! kustomize build deploy/kubernetes | grep -q "tools_db.json"; then
            echo "Warning: tools_db.json might not be properly included in ConfigMap"
          fi

      - name: Validate observability kustomization
        run: |
          echo "Validating observability stack kustomization..."
          if [ -d "deploy/kubernetes/observability" ]; then
            kustomize build deploy/kubernetes/observability > /tmp/observability-manifests.yaml
            echo "‚úì Observability kustomization is valid"
            
            # Verify expected resources
            for resource in "Deployment" "Service" "ConfigMap" "PersistentVolumeClaim"; do
              if ! grep -q "kind: $resource" /tmp/observability-manifests.yaml; then
                echo "Warning: $resource not found in observability manifests"
              fi
            done
          else
            echo "Observability directory not found, skipping..."
          fi

      - name: Validate AI Gateway configurations
        run: |
          echo "Validating AI Gateway configurations..."

          # Check if ai-gateway directory exists
          if [ -d "deploy/kubernetes/ai-gateway" ]; then
            # Validate configuration yamls (without CRDs)
            for yaml_file in deploy/kubernetes/ai-gateway/configuration/*.yaml; do
              if [ -f "$yaml_file" ]; then
                echo "Checking $yaml_file..."
                # Basic YAML syntax check
                kubectl create --dry-run=client -f "$yaml_file" || echo "Warning: Issues with $yaml_file"
              fi
            done
            
            # Validate inference-pool manifests (skip CRD validation as they may not be installed)
            for yaml_file in deploy/kubernetes/ai-gateway/inference-pool/*.yaml; do
              if [ -f "$yaml_file" ]; then
                echo "Checking $yaml_file for YAML syntax..."
                # Just check if it's valid YAML
                kubectl create --dry-run=client -f "$yaml_file" 2>&1 | grep -q "no matches for kind" && echo "‚úì $yaml_file syntax valid (CRD not installed)" || echo "Validated $yaml_file"
              fi
            done
            
            echo "‚úì AI Gateway configuration validation completed"
          else
            echo "AI Gateway directory not found, skipping..."
          fi

  security-scan:
    name: Security Scan for K8s Manifests
    runs-on: ubuntu-latest
    needs: validate-manifests

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Kustomize
        uses: imranismail/setup-kustomize@v2
        with:
          kustomize-version: ${{ env.KUSTOMIZE_VERSION }}

      - name: Run Trivy security scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "config"
          scan-ref: "deploy/kubernetes"
          format: "sarif"
          output: "trivy-results.sarif"
          severity: "CRITICAL,HIGH"
          exit-code: "0" # Don't fail on vulnerabilities, just report

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-results.sarif"

      - name: Run Checkov scan
        uses: bridgecrewio/checkov-action@master
        with:
          directory: deploy/kubernetes
          framework: kubernetes
          output_format: cli
          soft_fail: true # Don't fail the build

  summary:
    name: Test Summary
    runs-on: ubuntu-latest
    needs:
      [
        validate-manifests,
        kind-integration-test,
        test-api-functionality,
        test-with-custom-config,
        security-scan,
      ]
    if: always()

    steps:
      - name: Check test results
        run: |
          echo "=== Kubernetes Integration Test Summary ==="
          echo "Manifest Validation: ${{ needs.validate-manifests.result }}"
          echo "kind Integration Test: ${{ needs.kind-integration-test.result }}"
          echo "API Functionality Test: ${{ needs.test-api-functionality.result }}"
          echo "Custom Config Test: ${{ needs.test-with-custom-config.result }}"
          echo "Security Scan: ${{ needs.security-scan.result }}"

          # Count failures
          FAILURES=0
          if [[ "${{ needs.validate-manifests.result }}" == "failure" ]]; then
            echo "‚ùå Manifest validation failed"
            FAILURES=$((FAILURES + 1))
          fi
          if [[ "${{ needs.kind-integration-test.result }}" == "failure" ]]; then
            echo "‚ùå kind integration test failed"
            FAILURES=$((FAILURES + 1))
          fi
          if [[ "${{ needs.test-api-functionality.result }}" == "failure" ]]; then
            echo "‚ùå API functionality test failed"
            FAILURES=$((FAILURES + 1))
          fi
          if [[ "${{ needs.test-with-custom-config.result }}" == "failure" ]]; then
            echo "‚ùå Custom config test failed"
            FAILURES=$((FAILURES + 1))
          fi
          if [[ "${{ needs.security-scan.result }}" == "failure" ]]; then
            echo "‚ùå Security scan failed"
            FAILURES=$((FAILURES + 1))
          fi

          echo ""
          echo "=== Test Coverage ==="
          echo "‚úÖ Core deployment validation"
          echo "‚úÖ Service connectivity testing"
          echo "‚úÖ API functionality testing (14 comprehensive tests)"
          echo "‚úÖ Configuration validation"
          echo "‚úÖ Security scanning"
          echo "‚úÖ Error handling and edge cases"
          echo "‚úÖ Performance testing"

          if [ $FAILURES -gt 0 ]; then
            echo ""
            echo "‚ùå $FAILURES test(s) failed. Check the logs for details."
            exit 1
          else
            echo ""
            echo "‚úÖ All tests passed! Kubernetes deployment is fully validated."
          fi
