# Production environment values
# Optimized for production with high availability and security

replicaCount: 3

image:
  pullPolicy: IfNotPresent
  tag: "v0.1.0"  # Use specific version in production

imagePullSecrets:
  - name: ghcr-secret

# Production-grade resources
resources:
  limits:
    memory: "8Gi"
    cpu: "4"
  requests:
    memory: "4Gi"
    cpu: "2"

initContainer:
  resources:
    limits:
      memory: "2Gi"
      cpu: "1"
    requests:
      memory: "1Gi"
      cpu: "500m"

# Larger storage for production
persistence:
  size: 50Gi
  storageClassName: "fast-ssd"  # Use high-performance storage class

# Conservative probes for production
livenessProbe:
  initialDelaySeconds: 90
  periodSeconds: 30
  timeoutSeconds: 10
  failureThreshold: 3

readinessProbe:
  initialDelaySeconds: 120
  periodSeconds: 30
  timeoutSeconds: 10
  failureThreshold: 3

# Production configuration
config:
  bert_model:
    use_cpu: false  # Use GPU in production if available
    threshold: 0.7  # Higher threshold for production

  semantic_cache:
    enabled: true
    backend_type: "milvus"  # Use Milvus in production
    max_entries: 10000

  tools:
    enabled: true
    top_k: 5

  prompt_guard:
    enabled: true
    threshold: 0.8  # Stricter security in production

  vllm_endpoints:
    - name: "prod-endpoint-1"
      address: "10.0.1.10"
      port: 8000
      weight: 1
    - name: "prod-endpoint-2"
      address: "10.0.1.11"
      port: 8000
      weight: 1

  # Production API configuration
  api:
    batch_classification:
      max_batch_size: 200
      max_concurrency: 16
      metrics:
        enabled: true
        detailed_goroutine_tracking: false
        high_resolution_timing: false
        sample_rate: 0.1  # Sample 10% in production

# Enable autoscaling in production
autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

# Ingress configuration for production
ingress:
  enabled: true
  className: "nginx"
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
  hosts:
    - host: semantic-router.example.com
      paths:
        - path: /
          pathType: Prefix
          servicePort: 8080
  tls:
    - secretName: semantic-router-tls
      hosts:
        - semantic-router.example.com

# Service configuration
service:
  type: ClusterIP

# Pod security context for production
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000
  seccompProfile:
    type: RuntimeDefault

securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: false
  capabilities:
    drop:
      - ALL

# Pod anti-affinity for high availability
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                  - semantic-router
          topologyKey: kubernetes.io/hostname

# Node selector for production nodes
nodeSelector:
  node-role.kubernetes.io/worker: "true"

# Tolerations for production workloads
tolerations:
  - key: "workload"
    operator: "Equal"
    value: "production"
    effect: "NoSchedule"

# Pod disruption budget (requires separate resource)
# podDisruptionBudget:
#   enabled: true
#   minAvailable: 2
